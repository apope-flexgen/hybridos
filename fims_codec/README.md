# FIMS Codec API
## Overview
FIMS Codec is a Go library for compressing and decompressing collections of FIMS messages into and out of .tar.gz archive files. This would be done to be able to send a large amount of FIMS data over a network connection, such as with the CloudSync module. The bodies of all FIMS messages are expected to be `map[string]interface{}`s. The types of data allowed in this map are:
- numeric types that can fit into a `float64`, as all numeric data will type-casted to a `float64` during compression and be decompressed into a `float64`
- booleans
- strings
- slices of maps of strings to any nested data type

Data is allowed to be clothed in a nested map as long as it is found under the key "value".

For details on the format that FIMS messages must follow, see `powercloud_fims_format.md`.

## Encode API
The `Encoder` struct type is used to handle collecting FIMS messages and encoding them. A new `Encoder` can be instantiated using the `NewEncoder` function. FIMS messages can be added to the `Encoder` by passing their `map[string]interface{}` body to the `Encode` method of `Encoder`. When the first FIMS message is added to a new `Encoder`, the `Encoder` will use the data found in the map to configure a set of metadata describing each parsed key and its data type. This set of metadata will be used to handle adding future FIMS messages to the `Encoder`. If a FIMS message is added to an already-configured `Encoder` and it contains keys that were not in the original message that configured the `Encoder`, those keys will not be parsed. If a FIMS message is added to an already-configured `Encoder` and it is missing keys that were in the original message, "missing data markers" will be encoded. These will be recognized by the decoder, and the missing key will not show up in that individual FIMS message on the decoder side.

The FIMS messages added to an `Encoder` can be compressed into .tar.gz archive files by passing a destination directory to the `CreateArchive` method of `Encoder`. The archive file will be named "prefix"-"dashified URI"-"timestamp".tar.gz. The prefix is provided to the `CreateArchive` method, the dashified URI is the URI with the leading slash removed and all other slashes replaced with dashes, and the timestamp is the UNIX timestamp in microseconds marking the time the archive was created.

The two files compressed into the .tar.gz archive file are a metadata.txt file and a binary file containing all of the encoded FIMS messages. The name of the binary file containing the encoded FIMS messages is the stringified UNIX timestamp in microseconds of when the archive was created (same as the timestamp that shows up in the .tar.gz file name) with no file type extension. The encoding of FIMS messages happens as they are added to `Encoder`, so only the .tar.gz file creation has to happen when `CreateArchive` is called.

## metadata.txt
metadata.txt is essential for the decoder to know how to decode the encoded FIMS messages. It is a plain-text file that is written to with bytified strings and new-line characters delimiting each piece of information.

The first line of metadata.txt is the URI of the archived FIMS messages.

Following the first line, "additional data" is included in the metadata.txt such as database destination, database measurement, controller status, etc. The "additional data" is a map of strings to strings, and each key-value pair of the map is on its own line of metadata.txt. Each line of additional data is formatted as "additional data key":"additional data value". The end of "additional data" is marked by a blank line (this just manifests as a single extra new-line character).

After the empty line signifying the end of "additional data", the metadata for all keys of the FIMS messages begins. Each key is on its own line. The line is: the key string, a tab character (`\t`), and the stringified data type of the key. The stringified data type of the key is generated by the `reflect` package (`TypeOf(<value>).String()`).

Keys that are `float64`s or `bool`s only need that single line to describe them in metadata.txt. Strings and map slices require enumerations as well. Enumerations for strings and map-slices work very similarly. When the first FIMS message is added to an `Encoder`, each key that is a string or map-slice gets a set of enumerations of type `byte` and the value seen in the first FIMS message gets the enumeration `0x01`. In following FIMS messages, if a new value of string or map-slice is discovered, a new enumeration is added counting up (`0x00` is reserved to represent missing data). In metadata.txt, after the key-type pair line, enumerations are listed in order starting from `0x01`.

There is no blank line or special character separating key-type pair lines from other key-type pair lines, or even enumerations from key-type pair lines. The tab character (`\t`) is expected to only ever be found in key-type pair lines, so this is how the end of enumerations is recognized. This means that strings found in FIMS messages cannot have tabs in them, or else the encoding will be corrupted.

See `example_metadata.txt` for an example of a metadata.txt file.

## Decode API
The decoding API is simple, as most error-handling is done on the encoding side. Simply call the `Decode` function and pass it a path to a .tar.gz file. It will attempt to decode it, returning an error if it fails to do so. If successful, `Decode` will return a `DecodedData` struct. The four fields of `DecodedData` are: `Uri`, `MsgTimestamps`, `MsgBodies`, and `AdditionalData`. `Uri` is the URI of the decoded FIMS messages. `MsgTimestamps` is a slice of UNIX timestamps in microseconds as a `uint64` Each timestamp is associated with the message body that has the same index in `MsgBodies`, which is a slice of `map[string]interface{}`s. The timestamps and bodies are in separate slices rather than a custom data type to facilitate easier passing of the data through different modules (less dependency management). `AdditionalData` is a map of strings to strings containing "additional data" such as database destination, database measurement, controller status, etc.

## Encoded Data Format
Each encoded data file starts with 2 bytes that, when interpreted as a `uint16`, represent the number of messages encoded into the file. Then, each message is encoded one at a time. Each message encoding starts with 8 bytes that, when interpreted as a `uint64`, represent a UNIX timestamp in microseconds. This timestamp is the time at which the encoder received the message. Following the timestamp are all of the encoded values of each key, in the order that metadata.txt presents the keys. Bools are encoded as 0x00 for false, 0x01 for true, and 0xAB for a missing value. Float64s are encoded directly, bit-for-bit, into 8 bytes, with 0xFFDEADBEEFFF representing a missing value (this value is extremely large and outside our expecting data range). Strings and map slices are encoded with their enumerations or 0x00 for a missing value.
