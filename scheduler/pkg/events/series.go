package events

import (
	"errors"
	"fmt"
	"sort"
	"time"

	log "github.com/flexgen-power/go_flexgen/logger"
	"github.com/flexgen-power/scheduler/internal/flextime"
	"github.com/flexgen-power/scheduler/internal/idcache"
)

type Series struct {
	Id         idcache.Id  `json:"id"`
	Cycle      string      `json:"cycle"`      // options are: "day", "week" indicating how often series occurs. Use const strings defined below
	DayMask    byte        `json:"day_mask"`   // eight bits: (Most Significant Bits) 0 Sunday Monday Tuesday Wednesday Thursday Friday Saturday (Least Significant Bits)
	EndCount   int         `json:"end_count"`  // -1: never ends. 0: use EndTime instead. >0: ends after this number of occurrences. <-1: invalid.
	EndTime    time.Time   `json:"end_time"`   // if EndCount is 0, then series ends after this timestamp (last event iteration is allowed to fall on this timestamp, not after it)
	Exceptions []time.Time `json:"exceptions"` // timestamps on which the event should not occur
	Frequency  uint        `json:"frequency"`  // event repeats every Nth cycle
}

// Days of the week represented by a single bit at their respective positions in a day mask.
// Sunday is the only day that needs to be defined since all other days are generated by bit-shifting Sunday.
const Sunday = byte(0x40)

// Value used for cycle to represent a series repeating on a daily order of time.
const DailyRepeat = "day"

// Value used for cycle to represent a series repeating on a weekly order of time.
const WeeklyRepeat = "week"

// Byte value of 127 or 0x7F, so every weekday bit is high.
const EveryDayMask = byte(0b01111111)

// January 1, 2000 @ midnight UTC used as the placeholder value for series end time when end count is being used instead
var DefaultSeriesEndTime = time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)

// Returns a newly-allocated Series object that represents a non-repeating series.
// Because Repeat field of Event struct is a pointer, do not want to have a global
// NonRepeatingSeries or else edits to one event's non-repeating series pointer would
// affect all and ruin the desired const nature of this concept.
func NewNonRepeatingSeries() *Series {
	return &Series{
		Cycle:      DailyRepeat,
		DayMask:    EveryDayMask,
		EndCount:   1,
		EndTime:    DefaultSeriesEndTime,
		Exceptions: []time.Time{},
		Frequency:  1,
	}
}

func (ser *Series) isFiniteSeries() bool {
	return ser.EndCount >= 0
}

func (ser *Series) isInfiniteSeries() bool {
	return ser.EndCount < 0
}

func (ser *Series) hasException(timestamp time.Time) bool {
	for _, exception := range ser.Exceptions {
		if exception.Equal(timestamp) {
			return true
		}
	}
	return false
}

// Sorts the exception into the series's exceptions list, unless it already exists in the list.
func (ser *Series) addException(newException time.Time) {
	if ser.hasException(newException) {
		return
	}
	ser.Exceptions = append(ser.Exceptions, newException)
	ser.sortExceptions()
}

func (ser *Series) deleteException(timestamp time.Time) {
	for i, exception := range ser.Exceptions {
		if timestamp.Equal(exception) {
			ser.Exceptions = append(ser.Exceptions[:i], ser.Exceptions[i+1:]...)
			return
		}
	}
}

// Deletes any exceptions from the series's exception list that are before the given reference time.
// Returns false if there were no exceptions found that came before the reference time.
func (ser *Series) DeleteExceptionsBefore(referenceTime time.Time) (exceptionsDeleted bool) {
	newStartingIndex := 0
	for _, exception := range ser.Exceptions {
		if exception.Before(referenceTime) {
			log.Infof("Pruning old exception %v from series with ID %v.", exception, ser.Id)
			newStartingIndex++
		}
	}
	if newStartingIndex == 0 {
		return false
	}
	ser.Exceptions = ser.Exceptions[newStartingIndex:]
	return true
}

// Sorts the exceptions from earliest to latest.
func (ser *Series) sortExceptions() {
	sort.Slice(ser.Exceptions, func(i, j int) bool {
		return ser.Exceptions[i].Before(ser.Exceptions[j])
	})
}

// Validates the exceptions slice by making sure it is instantiated, deleting any exceptions that occur before the start time,
// aligning all exceptions with the start time, and sorting the exceptions chronologically.
func (ser *Series) validateExceptions(startTime time.Time) {
	previouslyExistingExceptions := ser.Exceptions
	ser.Exceptions = make([]time.Time, 0, len(ser.Exceptions))
	for _, exception := range previouslyExistingExceptions {
		alignedException := flextime.ApplyNewDateToTime(exception, startTime)
		if !alignedException.Before(startTime) {
			ser.addException(alignedException) // handles sorting and filtering out duplicates
		}
	}
}

// If the series ends after a number of occurrences, decrements the end integer.
// Returns whether or not the series has ended.
func (ser *Series) updateSeriesEnd(nextStartTime time.Time) (seriesOver bool) {
	// series never ends
	if ser.isInfiniteSeries() {
		return false
	}

	// series ends after the recorded number of occurrences
	if ser.EndCount > 0 {
		ser.EndCount = ser.EndCount - 1
		return ser.EndCount == 0
	}

	// EndCount being 0 means that EndTime should be used as the reference to determine when series ends
	return nextStartTime.After(ser.EndTime)
}

// calculateDaysUntilNextOccurrence finds how many days must be added to the previous occurrence
// of a series to get to the next occurrence of a series. For "day" cycle series, this is simply
// n. But for "week" cycle series, the previous occurrence's weekday is required and the day mask
// must be analyzed to determine which day happens next.
func (ser *Series) calculateDaysUntilNextOccurrence(lastOccurrenceWeekday time.Weekday) (daysUntilNextOccurrence uint) {
	switch ser.Cycle {
	case DailyRepeat:
		daysUntilNextOccurrence = ser.Frequency
	case WeeklyRepeat:
		if ser.DayMask == 0 {
			log.Errorf("Discovered invalid day_mask of 0 in event repeat settings.")
			return 0
		}
		currentWeekday := weekdayEnumToMask(lastOccurrenceWeekday)
		nextWeekday := currentWeekday
		for nextWeekday != 0 {
			nextWeekday = nextWeekday >> 1
			daysUntilNextOccurrence++
			if (nextWeekday & ser.DayMask) != byte(0x00) {
				break
			}
		}
		if nextWeekday == 0 {
			nextWeekday = Sunday
			for nextWeekday != currentWeekday {
				if (nextWeekday & ser.DayMask) != byte(0x00) {
					break
				}
				nextWeekday = nextWeekday >> 1
				daysUntilNextOccurrence++
			}
		}
		// add extra weeks if frequency is configured to skip weeks for this series
		daysUntilNextOccurrence += (ser.Frequency - 1) * 7
	}
	return daysUntilNextOccurrence
}

// Takes a weekday in the form of the time package's enumerations (Sunday = 0, Monday = 1,..., Saturday = 6)
// and returns a weekday in the form of a Scheduler day mask (Sunday = 0x40, Monday = 0x20,..., Saturday = 0x01).
func weekdayEnumToMask(enum time.Weekday) (mask byte) {
	return Sunday >> byte(enum)
}

// returns a pointer to a copy of the given Series object
func (ser Series) copy() *Series {
	seriesCopy := ser
	seriesCopy.Exceptions = make([]time.Time, len(ser.Exceptions))
	copy(seriesCopy.Exceptions, ser.Exceptions)
	return &seriesCopy
}

func (ser *Series) print() {
	if ser == nil {
		return
	}
	fmt.Println("cycle:", ser.Cycle)
	fmt.Println("frequency:", ser.Frequency)
	fmt.Println("day_mask:", ser.DayMask)
	fmt.Println("end_count:", ser.EndCount)
	fmt.Println("end_time:", ser.EndTime)
	fmt.Println("exceptions:", ser.Exceptions)
}

// Checks for "deep" equality, so all fields must be equal. Exceptions slice must have same length
// and same elements in each index of the array.
func (ser1 *Series) equals(ser2 *Series) (areEqual bool, reasonNotEqual string) {
	if ser1 == nil {
		if ser2 != nil {
			return false, "ser1 is nil but ser2 is not"
		}
		return true, ""
	}
	if ser2 == nil {
		return false, "ser2 is nil but ser1 is not"
	}

	if ser1.Cycle != ser2.Cycle {
		return false, fmt.Sprintf("ser1 cycle %s does not match ser2 cycle %s", ser1.Cycle, ser2.Cycle)
	}

	if ser1.DayMask != ser2.DayMask {
		return false, fmt.Sprintf("ser1 day mask %d does not match ser2 day mask %d", ser1.DayMask, ser2.DayMask)
	}

	if ser1.EndCount != ser2.EndCount {
		return false, fmt.Sprintf("ser1 end count %d does not equal ser2 end count %d", ser1.EndCount, ser2.EndCount)
	}

	if !ser1.EndTime.Equal(ser2.EndTime) {
		return false, fmt.Sprintf("ser1 end time %s does not equal ser2 end time %s", ser1.EndTime, ser2.EndTime)
	}

	if ser1.Frequency != ser2.Frequency {
		return false, fmt.Sprintf("ser1 frequency %d does not equal ser2 frequency %d", ser1.Frequency, ser2.Frequency)
	}

	if len(ser1.Exceptions) != len(ser2.Exceptions) {
		return false, fmt.Sprintf("length of ser1 exceptions %v does not match length of ser2 exceptions %v", ser1.Exceptions, ser2.Exceptions)
	}

	for i, exception := range ser1.Exceptions {
		if !exception.Equal(ser2.Exceptions[i]) {
			return false, fmt.Sprintf("exception with index %d in ser1 is %s but in ser2 it is %s", i, exception, ser2.Exceptions[i])
		}
	}

	return true, ""
}

func (s *Series) validate(startTime time.Time) error {
	// when repeat settings not included in larger event and/or schedule object, default to non-repeating series
	if s == nil {
		return errors.New("nil pointer")
	}

	if s.Cycle != DailyRepeat && s.Cycle != WeeklyRepeat {
		return fmt.Errorf("received %s for cycle which is invalid", s.Cycle)
	}

	// 8th bit should always be 0 but if given a mask with 8 bit high that's okay, just lower it
	s.DayMask &= EveryDayMask
	if s.DayMask == 0 {
		if s.Cycle == WeeklyRepeat {
			return errors.New("day_mask needs at least one high bit for weekly events")
		}
		s.DayMask = EveryDayMask
	}

	s.validateExceptions(startTime)

	if s.Frequency == 0 {
		return errors.New("frequency cannot be 0")
	}

	if s.EndCount < -1 {
		return fmt.Errorf("received end_count of %d but end_count cannot be less than -1", s.EndCount)
	}

	// end_time is only used as end reference if end_count is 0, so if end_count is not 0 set end_time
	// to placeholder value to make it obvious that end_time is not being used
	if s.EndCount != 0 {
		s.EndTime = DefaultSeriesEndTime
		return nil
	}

	// if end_time is used as end reference, it must come after the series's next start time
	if !s.EndTime.After(startTime) {
		return fmt.Errorf("series end time %v is not after start time %v", s.EndTime, startTime)
	}
	return nil
}
