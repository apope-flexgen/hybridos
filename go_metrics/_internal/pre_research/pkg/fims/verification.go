/**
 * Verification
 * verification.go
 *
 * Created January 2022
 *
 * Library used to expand upon the functionality of replyto to be used for SET and POST (and later DEL)
 * verification. Includes unique id generation to differentiate between multiple messages being issued on
 * the same variable endpoint within a similar timeframe and a thread-safe record of these ids and their
 * associated fims messages for verification tracking
 */

package fims

import (
	"fmt"
	"regexp"
	"strconv"
	"sync"
	"time"
)

type verificationRecordEntry struct {
	recordType string    // Type of record tracking used by the associated endpoint (key), either "all" or "latest"
	id         int       // Unique id generated by go_fims
	timeSent   time.Time // Time at which the message was issued from the sending service, used for timeout
	msg        FimsMsg   // Record of the fims message sent
}

type AtomicVerificationRecords struct {
	AtomicLock            sync.Mutex                         // Mutex to ensure accessing/modifying the records is atomic
	VerificationRecordMap map[string]verificationRecordEntry // The string key of each entry is it's replyto base uri, without any unique id appended
}

var VerificationRecords AtomicVerificationRecords         // Thread safe map, accessed atomically
var expiredTimeout time.Duration                          // How long to wait before data is considered "expired"
var callbackAction func(msgRecord map[string]interface{}) // User defined function to execute upon successful verification of a set
var idCounters map[string]int                             // List of unique ids per base replyto uri (key)
var messagesIssued uint                                   // Total number of messages that have been tracked
var messagesVerified uint                                 // Total number of messages that have been successfully verified

// Configure the library
func ConfigureVerification(configuredTimeoutMins int, configuredCallbackAction func(msgRecord map[string]interface{})) {
	expiredTimeout = time.Duration(configuredTimeoutMins) * time.Minute
	// Callback may be nil
	callbackAction = configuredCallbackAction
	VerificationRecords = AtomicVerificationRecords{sync.Mutex{}, make(map[string]verificationRecordEntry)}
	idCounters = make(map[string]int)
	messagesIssued = 0
	messagesVerified = 0
}

// Atomically access a single record in the VerificationRecords map
func (records *AtomicVerificationRecords) get(key string) (entry verificationRecordEntry, ok bool) {
	records.AtomicLock.Lock()
	defer records.AtomicLock.Unlock()

	entry, ok = records.VerificationRecordMap[key]
	return
}

// Add a record to the map of messages waiting to be validated
// recordType determines whether "all" records added should be given a unique uri, or if only the "latest" is tracked
// For the use case where all messages are tracked, both the record's id (unique id) and key (replyto) will be unique
//		this ensures that every message we receive will have a unique entry in the records map
// For the use case where only the latest are tracked, only the record's id (unique id) will be unique
// 		this ensures that the entry in the records will be overwritten when the same replyto uri (key) is received
// Returns true if the record was added, along with the uri, but may return error as well for the case where "all"
//		messagages are being tracked but the record was written due to the 1000 message limit
func (records *AtomicVerificationRecords) addVerificationRecordEntry(recordType string, msg FimsMsg) (bool, string, error) {
	records.AtomicLock.Lock()
	defer records.AtomicLock.Unlock()

	// Make sure configuration has taken place
	if records.VerificationRecordMap == nil {
		return false, "", fmt.Errorf("verification record map undefined")
	}

	if msg.Replyto == "" {
		return false, "", fmt.Errorf("no replyto uri provided")
	}

	// Use the base replyto provided as the key in the map for type "latest"
	uriKey := msg.Replyto
	// Use the base replyto uri for unique id generation as well
	uniqueID := GetUniqueID(uriKey)
	// Always add the unique id to the replyto uri regardless of type
	msg.Replyto += "/" + strconv.Itoa(uniqueID)
	var err error

	if recordType == "all" {
		// Use the full replyto with id appended as the key in the map for type "all"
		uriKey = msg.Replyto
		// For this record type, make sure to flag and return a message if the message limit has been reached
		// and we need to overwrite one of our messages with the same uriKey
		if overwrittenEntry, ok := records.VerificationRecordMap[uriKey]; ok {
			err = fmt.Errorf("unique id %d already in use by message: %v", uniqueID, overwrittenEntry.msg)
		}
	}

	// Construct the entry and add it to the records
	entry := verificationRecordEntry{recordType, uniqueID, time.Now(), msg}
	records.VerificationRecordMap[uriKey] = entry
	messagesIssued++

	return true, msg.Replyto, err
}

// Remove a record from the map of messages waiting to be verified
func (records *AtomicVerificationRecords) deleteVerificationRecordEntry(replytoKey string) {
	records.AtomicLock.Lock()
	defer records.AtomicLock.Unlock()

	delete(records.VerificationRecordMap, replytoKey)
}

// Remove all given records from the map of messages waiting to be verified
func (records *AtomicVerificationRecords) deleteVerificationRecords(replytoKeys []string) {
	records.AtomicLock.Lock()
	defer records.AtomicLock.Unlock()

	for _, replytoKey := range replytoKeys {
		delete(records.VerificationRecordMap, replytoKey)
	}
}

// Searches through the records for any unverified messages that are still active
// Will also clear out any expired messages
// In general, this function will be called implicitly as part of ResendUnverifiedMessages()
// but it has been exported for external use as well if desired
func (records *AtomicVerificationRecords) GetUnverifiedMessages() (map[string]verificationRecordEntry, error) {
	// Make sure configuration has taken place
	if records.VerificationRecordMap == nil {
		return nil, fmt.Errorf("verification record map undefined")
	}

	// Map of unverified messages to return
	unverifiedMap := make(map[string]verificationRecordEntry)
	// List of keys that have expired and should be deleted
	var expiredList []string

	records.AtomicLock.Lock()
	// Look through records and copy any unverified messages that are still valid
	for key, val := range records.VerificationRecordMap {
		if time.Since(val.timeSent) < expiredTimeout {
			// Record is still valid, add it to the map being returned
			unverifiedMap[key] = val
		} else {
			// Record is expired, mark it for deletion
			expiredList = append(expiredList, key)
		}
	}
	records.AtomicLock.Unlock()
	// Remove any expired records
	records.deleteVerificationRecords(expiredList)

	return unverifiedMap, nil
}

// Checks if the message is a verification response, and removes the response if so
// As we don't know if the response is for record type "all" or "latest", first check if the entry is present for the given uri
// If not, check if a unique id is present, and if so, try removing it and checking just the base replyto uri ("latest" use case)
func (records *AtomicVerificationRecords) handleVerificationResponse(msg FimsMsg) {
	// Make sure configuration has taken place
	if records.VerificationRecordMap == nil {
		return
	}
	// First perform the check for records tracking "all" messages
	if entry, ok := records.get(msg.Uri); ok {
		// The record exists for the replyto received, so simply remove it
		records.deleteVerificationRecordEntry(msg.Uri)
		HandleSuccessfulVerification(entry)
	} else if msg.Nfrags > 1 {
		// Next check for the records using the "latest" schema
		// Pattern matching the end of the string with a numeric id fragment
		regexSuffix := regexp.MustCompile("/[0-9]+$")
		substrPos := regexSuffix.FindStringIndex(msg.Uri)
		if len(substrPos) == 2 && substrPos[1] == len(msg.Uri) {
			baseUriKey := msg.Uri[0:substrPos[0]]
			// Now check if a record exists for the base Uri (all records use same key), and ensure the ids match
			if entry, ok := records.get(baseUriKey); ok {
				if extractedId, _ := strconv.Atoi(msg.Uri[substrPos[0]+1 : substrPos[1]]); extractedId == entry.id {
					// The record exists for the replyto received, so simply remove it from the record of unverified messages
					records.deleteVerificationRecordEntry(baseUriKey)
					HandleSuccessfulVerification(entry)
				}
			}
		}
	}
	// No record matched, simply return
}

// Delete the records map and reset id generation
func (records *AtomicVerificationRecords) ResetRecords() {
	records.AtomicLock.Lock()
	records.VerificationRecordMap = make(map[string]verificationRecordEntry)
	idCounters = make(map[string]int)
	records.AtomicLock.Unlock()
}

// Uses an internal counter which increments each time this function is called to create a unique id for the
// given base replyto uri. This is used to differentiate between multiple messages on the same uri issued at
// similar times.
func GetUniqueID(uri string) int {
	defer func() {
		idCounters[uri]++
		// As this unique id is appended to the repyto uri, keep it's length short (4 bytes including the "/")
		// This sets a hard cap of 1000 possible unique ids for a specific uri
		idCounters[uri] %= 1000
	}()
	return idCounters[uri]
}

// Call the user-defined callback function if configured, and increment the number of verified messages
func HandleSuccessfulVerification(entry verificationRecordEntry) {
	messagesVerified++
	if callbackAction != nil {
		arg := map[string]interface{}{
			"id":         entry.id,
			"timeSent":   entry.timeSent,
			"msg":        entry.msg,
			"recordType": entry.recordType,
		}
		callbackAction(arg)
	}
}

// Accessors/mutators for fims stats
func GetVerificationMessagesIssued() uint {
	return messagesIssued
}
func GetVerificationMessagesVerified() uint {
	return messagesVerified
}

// Caller cannot directly access the stats to modify them, but can reset them as needed
func ResetVerificationMessageStats() {
	messagesIssued = 0
	messagesVerified = 0
}
