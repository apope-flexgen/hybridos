How the new internal rewrite of fims works:

The problem:
- Previously fims used send and recv over the unix socket file descriptor.
- This required one buffer that was encrypted and represented as a json string
- Furthermore, this also required that every program that interfaced with fims needed a json parser along with the server
- This require lots of "stringification" and added in a json parser and stringifier dependency to all languages
- Furthermore, the "stringification" process of the "body" (applicatin data) required escaping special characters in order
    to fit it into a string ("quotation marks") due to how json parsing works
- For example:
    - body = {"hello":"world"}
    - the output would need to be: "{\"hello\":\"world\"}"
    - this would add an extra \ character per quotation mark in the "body" string
    - Furthermore, each "special" character also needs this
    - This includes \n \t etc. (any special \ character really -> including \ itself)
- Obviously this massively increases data size in order to escape body strings and is not very performant
- Lastly, the extra json parser/stringification dependency is largely unnecessary and adds complexity

- extra problem:
- Due to using a json string to pass around application data and "meta data" (uri, method, replyto, etc.)
    encryption had to encrypt and decrypt the entire json string
- This means that the server and all applications have to "decrypt" the entire json string before getting to meta data
- This means the server has to waste time decrypting entire swaths of data before determining where to send it

The solution:
- Instead of using a json parser and stringifier to pass data around unix sockets
- simply use "vectored I/O" and interpret "bytes" as necessary when passing messages around
- Furthermore, "meta data" can be separate from the application data for encryption/decryption,
    which allows for a true "zero parse/decryption" fims_server
- All of this can be done internally to fims without changing any higher level API (and therefore not break any applications)
- This solution produced a 10:1 speedup in performance (without encryption)

The new data layout:
- Currently the new fims data passing convention will pass around data in the following form:
    - Meta_Data_Info_Struct, byte_array[[meta_data_bytes][encrypted/unecrypted application data]]
- Meta_Data_Info:
    - Contains lengths of data/bytes (useful for offsets, etc.)
    - u8: method_len, uri_len, replyto_len, sender_name_len
    - u32: data_len
- byte_array
    - All data (apart form meta_info) is received into this byte array
    - The first X bytes are dedicated to fully unecrypted meta_data (for now these are all chars)
    - The last X bytes (after meta data info) is the actual application data (for now this is "body" -> actual json string)
    - Meta_Data_Info struct is used to get offsets into the byte array (and also for zero copy stuff -> like str_view)

Versioning:
- Because fims now uses byte interpretation to extract out information and not a json parser
    interpretation versioning is necessary.
- This is contained in the macro "FIMS_DATA_LAYOUT_VERSION"

Handshake between server and clients:
- versioning and "MAX_MESSAGE_SIZE" are determined through a "handshake" between the server the clients
- if the data_layout_version between the server and the client are different then communication is impossible
    and will therefore be cut off after the initial handshake
- If the handhsake succeeds then "max_message_size" will be set on the client through the fims struct
    which now has a function to get that information
- This means that MAX_MESSAGE_SIZE is removed as a macro and receivers using libfims should allocated enough space
    for their application as "expected" or heap allocate enough space once after calling Connect()
    - This unified the total number of bytes needed for sending and receiving and makes people less dependent on macros
    - Also, this allows for proper error checking for the unix socket size based on how much data the server can receive
        making for easy error checking in send functions.


[Meta_Data_Info] // header (sizes and lengths)
byte array [[meta_data_strings -> unecrypted][application data -> encrypted/decrypted]]


// send and recv did this:

- malloc (all the bytes together) -> cjson did this (json "stringifier")
- send whole buffer out as a single void* and size
- this requires lots of time in "user space" instead of having the kernel do the data copying itself
- vectored I/O helps in "zero copy" code for senders

// previously using json (encrypt then decrypt this whole thing server side):
{"method":"some_method","uri":"/some/uri","replyto":"/some/replyto/uri","body (this is "data")":"{\"hello\":\"world\"}"}

// now it looks something like this:
Meta_Data_Info = { method_len = 11, uri_len = 9, replyto_len = x, sender_name_len = y, data_len = 17 }
bytes_array = [some_method/some/uri/some/replyto/uri{"hello":"world"}] // in the byte array it would look like this

// use "lens" as offsets and string sizes to extract out the "fims_message"

// subscribe works differently now:
byte_array = [[sub][num_subs -> u8][{bool, u8 -> str_size}][char array -> non-null-terminated]]
